\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{geometry}

\geometry{margin=1in}

\definecolor{background}{rgb}{1.00, 1.00, 1.00}
\definecolor{brightred}{rgb}{0.80, 0.03, 0.16}
\definecolor{brightorange}{rgb}{0.79, 0.28, 0.08}

\lstdefinestyle{custom-style}{
    frame=single,
    upquote=true,
    rulecolor=\color{gray},
    backgroundcolor=\color{background},
    stringstyle=\color{brightred},
    keywordstyle=\color{brightorange},
    numberstyle=\scriptsize\color{gray},
    basicstyle=\ttfamily\footnotesize,
    literate=%
        {|}{{{\color{brightorange}|}}}1
        {::=}{{{\color{brightorange}::=}}}3,
    breakatwhitespace=false,
    breaklines=true,
    keepspaces=true,
    numbers=left,
    numbersep=8pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\date{}
\title{
    \includegraphics[width=0.67\linewidth]{logo.pdf} \\
    an interpreted imperative programming \\ language that wants to believe
}
\author{Lorenzo Loconte}

\begin{document}
\maketitle

\section*{Introduction}
\textbf{Shrimp} is a simple imperative programming language designed during the course of \textit{Formal Methods for Computer Science} at Universita' degli Studi di Bari Aldo Moro.
\textbf{Shrimp} uses an \textit{eager evaluation strategy}.
In order to ensure that, the interpreter executes the code using the \textit{call by value} method.

\section*{Software Modules}
The program is composed by three main components:
\begin{itemize}
    \item The \textbf{parser}
    \item The \textbf{optimizer}
    \item The \textbf{interpreter}
\end{itemize}

The \textbf{parser} takes in input the source code and convert it to an intermediate representation.
The intermediate representation (IR) have the structure of a n-ary tree having the non-terminals of the grammar as internal nodes and commands, identifiers and constants on the leaves.

The \textbf{optimizer} takes in input the intermediate representation given by the parser.
The result of the optimizer is an \textit{optimized} intermediate representation.
It evaluates the constant expressions (both arithmetic and boolean) that might be present in the source code and replace them with the resulting constants.
The optimizer also checks for empty commands block and useless branch statements.

The \textbf{interpreter} execute the semantics present in an intermediate representation.
The basic idea is to use a \textbf{state} (or environment) that collects the values of the variables during the execution of the program.
The result of the interpretation is the resulting state, that is a set of assignments to the variables.

\section*{The Language Syntax}
The syntax for the \textbf{Shrimp} programming language is a context-free grammar.
So, it can be denoted using EBNF (Extended Backus Naur Form) as following:
\begin{lstlisting}[language=C, style=custom-style]
Type ::= "int"
Integer ::= [0-9]+
Identifier ::= [a-zA-Z_]+
Program ::= "shrimp" Block
Block ::= [Command]*
Command ::= {Assignment | Branch | Loop}
Assignment ::= Identifier "=" ArithmeticExpr ";"
Branch ::= "if" "(" BooleanExpr ")" "then" Block
           ["else" Block] "end if" ";"
Loop ::= "while" "(" BooleanExpr ")" "do"
         Block "end while" ";"

ArithmeticExpr ::=
    ArithmeticTerm "+" ArithmeticExpr
  | ArithmeticTerm "-" ArithmeticExpr
  | ArithmetciTerm
ArithmeticTerm ::=
    ArithmeticFactor "*" ArithmeticTerm
  | ArithmeticFactor "/" ArithmeticTerm
  | ArithmeticFactor "%" ArithmeticTerm
  | ArithmeticFactor
ArithmeticFactor ::=
    Integer
  | Identifier
  | "-" ArithmeticExpr
  | "(" ArithmeticExpr ")"

BooleanExpr ::=
    BooleanTerm "or" BooleanExpr
  | BooleanTerm
BooleanTerm ::=
    BooleanFactor "and" BooleanTerm
  | BooleanFactor

BooleanFactor ::=
    "true"
  | "false"
  | "not" BooleanExpr
  | ArithmetciExpr "eq" ArithmeticExpr
  | ArithmetciExpr "neq" ArithmeticExpr
  | ArithmetciExpr "lt" ArithmeticExpr
  | ArithmetciExpr "gt" ArithmeticExpr
  | ArithmetciExpr "leq" ArithmeticExpr
  | ArithmetciExpr "geq" ArithmeticExpr
  | "(" BooleanExpr ")"
\end{lstlisting}
Some of the non-terminals of this context-free grammar are reported directly in Haskell.
That is, I defined an \textit{abstract syntax tree} that also represents the intermediate representation of a program.
This intermediate representation will be the result of the parser.
Moreover, the presence of an intermediate representation permits us to apply optimizations \textit{at prior} respect to the interpretation step.
The following code snippet contains the definition of the \textit{abstarct syntax tree}.
\begin{lstlisting}[language=Haskell, style=custom-style]
data ArithmeticExpr
  = Add ArithmeticExpr ArithmeticExpr
  | Sub ArithmeticExpr ArithmeticExpr
  | Mul ArithmeticExpr ArithmeticExpr
  | Div ArithmeticExpr ArithmeticExpr
  | Mod ArithmeticExpr ArithmeticExpr
  | Neg ArithmeticExpr
  | Constant Int
  | Identifier String
  deriving (Eq, Show)

data BooleanExpr
  = Boolean Bool
  | Not BooleanExpr
  | Or BooleanExpr BooleanExpr
  | And BooleanExpr BooleanExpr
  | Equal ArithmeticExpr ArithmeticExpr
  | NotEqual ArithmeticExpr ArithmeticExpr
  | Less ArithmeticExpr ArithmeticExpr
  | Greater ArithmeticExpr ArithmeticExpr
  | LessEqual ArithmeticExpr ArithmeticExpr
  | GreaterEqual ArithmeticExpr ArithmeticExpr
  deriving (Eq, Show)

data Command
  = Skip
  | Assignment String ArithmeticExpr
  | Branch BooleanExpr Block Block
  | Loop BooleanExpr Block
  deriving (Eq, Show)

type Block = [Command]
\end{lstlisting}

\section*{The Parser}
The parser can be viewed as a function from a string to a list of pairs of values and strings (Graham Hutton).
\begin{lstlisting}[language=Haskell, style=custom-style]
newtype Parser a = Parser {unwrap :: String -> [(a, String)]}
\end{lstlisting}
Note that the parser have a special function called \texttt{unwrap} that takes the function out from the parser.
The parser is implemented in a ``monadic'' way.
That is, I implemented the following interfaces: \textit{monad plus} and \textit{monad alternative} as suggested in \textit{Monadic Parsing in Haskell} (Hutton \& Meijer).
In order to implement the monad interface I also implemented the \textit{functor} and \textit{applicative} interfaces as in the following code snippet.
\begin{lstlisting}[language=Haskell, style=custom-style]
instance Functor Parser where
fmap f p = Parser (\cs ->
  [(f a, cs') | (a, cs') <- unwrap p cs])

instance Applicative Parser where
pure a = Parser (\cs -> [(a, cs)])
p <*> q = Parser (\cs -> concat
  [unwrap (fmap a q) cs' | (a, cs') <- unwrap p cs])
\end{lstlisting}

The functor implementation for the parser implements the \texttt{fmap} function, that is the application of a function on a wrapped parser.
Moreover, the applicative implementation for the parser implement both the function \texttt{pure} and the operator \texttt{<*>}.
The \texttt{pure} function takes a simple values and wraps it into a parser.
The \texttt{<*>} operator takes in input a function wrapped in a parser and another parser.
The result is the application of the wrapped function onto the parser.

The next step is to implement the standard monad interface.
Moreover, two more interfaces are implemented: \texttt{MonadPlus} and \texttt{MonadAlternative}.
The \texttt{plus} operator defined on parsers concatenates the result of each one.
Moreover, the \texttt{MonadAlternative} give us an operator \texttt{<|>} useful for combining parsers in a mutually exclusive way.
The classes definition can be found in the following code snippet.
\begin{lstlisting}[language=Haskell, style=custom-style]
class (Monad m) => MonadPlus m where
zero :: m a
plus :: m a -> m a -> m a

class (MonadPlus m) => MonadAlternative m where
(<|>) :: m a -> m a -> m a
many :: m a -> m [a]
many m = some m <|> return []
some :: m a -> m [a]
some m = liftA2 (:) m (many m)
\end{lstlisting}
Note that the function \texttt{liftA2} is the composition of \texttt{fmap} and the applicative operator \texttt{<*>}.
The functions \texttt{many} and \texttt{some} are called \textit{combinators} and are used to define the concept of repeated parsing.
The \texttt{many} function refers to zero to any number of applications of a parser while the \texttt{some} function refers to at least one to any number of applications of a parser.
The implementation for the parser of the monad sequencing and the other functions and operators described before is the following.
\begin{lstlisting}[language=Haskell, style=custom-style]
instance Monad Parser where
return a = pure a
p >>= f = Parser (\cs -> concat
  [unwrap (f a) cs' | (a, cs') <- unwrap p cs])

instance MonadPlus Parser where
zero = Parser (const [])
p `plus` q = Parser (\cs -> unwrap p cs ++ unwrap q cs)

instance MonadAlternative Parser where
(<|>) p q = Parser (\cs ->
  case unwrap (p `plus` q) cs of
    [] -> []
    (x : _) -> [x])
\end{lstlisting}

The \texttt{zero} operator defines what is an empty parser.
Note that in this context an empty parser is a \textit{failed} parser, that is a parser that results from a syntactical error.
The \texttt{plus} operator concatenates the results of two individual parsers.
Using the monadic definition of parser, it permits us to easily build a parser for each structure of the programming language, without having to handle the eventual parsing errors individually.
For example, it's possible to define a parser for symbols, identifiers and integers as in the following code snippet.
Moreover, since the parser implements the \texttt{MonadAlternative} interface described above, the combination of multiple parsers is straightforward and easily parallelizable.
\begin{lstlisting}[language=Haskell, style=custom-style]
item :: Parser Char
item = Parser (\case "" -> []; (c : cs) -> [(c, cs)])

satisfy :: (Char -> Bool) -> Parser Char
satisfy p = do c <- item; if p c then return c else zero

token :: Parser a -> Parser a
token p = do space; v <- p; space; return v

space :: Parser String
space = many $ satisfy isSpace

identifier :: Parser String
identifier = token $ some $ satisfy isLetter

constant :: Parser Int
constant = read <$> token (some $ satisfy isDigit)

char :: Char -> Parser Char
char c = satisfy (c ==)
\end{lstlisting}
That is, I firstly defined a \texttt{item} function that reads a character from the string.
Then I defined a function called \texttt{satisfy} that apply a constraint to the character read by the parser.
This function returns an \texttt{zero} parser if the constraint is not satisfied.
In the end, using both the combinators \texttt{many} and \texttt{some}, I built parsers for identifiers, constants and also spaces that are the main blocks of the context-free grammar already defined.
In the same way, it's possible to define a parser for other constructs, such as keywords and symbols.
\begin{lstlisting}[language=Haskell, style=custom-style]
keyword :: String -> Parser String
keyword cs = token $ word cs

word :: String -> Parser String
word [c] = do char c; return [c]
word (c : cs) = do char c; word cs; return (c : cs)

symbol :: Char -> Parser Char
symbol c = token $ char c
\end{lstlisting}
In order to build parsers for both arithmetic and boolean expression the \texttt{<|>} operator between parsers is used.
So, I define the parser for arithmetic expressions using other sub-parsers that are used in order to maintain the operators precedence.
The parser for boolean expressions is similar to the parser for arithmetic expressions and so it's omitted.
\begin{lstlisting}[language=Haskell, style=custom-style]
arithmeticExpr :: Parser ArithmeticExpr
arithmeticExpr = do
  a <- arithmeticTerm
    do symbol '+'; Add a <$> arithmeticExpr
    <|> do symbol '-'; Sub a <$> arithmeticExpr
    <|> do return a

arithmeticTerm :: Parser ArithmeticExpr
arithmeticTerm = do
  a <- arithmeticFactor
    do symbol '*'; Mul a <$> arithmeticTerm
    <|> do symbol '/'; Div a <$> arithmeticTerm
    <|> do symbol '%'; Mod a <$> arithmeticTerm
    <|> do return a

arithmeticFactor :: Parser ArithmeticExpr
arithmeticFactor =
  do Constant <$> constant
  <|> do Identifier <$> identifier
  <|> do symbol '-'; Neg <$> arithmeticExpr
  <|> do symbol '('; a <- arithmeticExpr; symbol ')'; return a
\end{lstlisting}
In the end we have a parser for every command described in the grammar.
So, I defined a parser for the following commands: \texttt{skip}, \texttt{assignment}, \texttt{if-then-else}, and \texttt{while-do}.
\begin{lstlisting}[language=Haskell, style=custom-style]
assignment :: Parser Command
assignment = do
  d <- identifier
  symbol '='
  a <- arithmeticExpr
  symbol ';'
  return (Assignment d a)

branch :: Parser Command
branch = do
  keyword "if"
  symbol '('
  b <- booleanExpr
  symbol ')'
  keyword "then"
  c1 <- block
  do
    keyword "else"
    c2 <- block
    keyword "end if"
    symbol ';'
    return (Branch b c1 c2)
    <|> do
      keyword "end if"
      symbol ';'
      return (Branch b c1 [Skip])

loop :: Parser Command
loop = do
  keyword "while"
  symbol '('
  b <- booleanExpr
  symbol ')'
  keyword "do"
  c <- block
  keyword "end while"
  symbol ';'
  return (Loop b c)

skip :: Parser Command
skip = do
  keyword "skip"
  symbol ';'
  return Skip
\end{lstlisting}
It's important to notice that the grammar also allows for \texttt{if-then} statements (i.e. without the \texttt{else} command block).
A parser that works on both \texttt{if-then-else} and \texttt{if-then} statements is implemented by combining the two parsers using the \texttt{<|>} operator.
Moreover, using the \texttt{many} combinator and the \texttt{<|>} operator, the parsers for both multiple commands and a single command are straightforward.
\begin{lstlisting}[language=Haskell, style=custom-style]
block :: Parser Block
block = many command

command :: Parser Command
command = assignment <|> branch <|> loop <|> skip
\end{lstlisting}
The parser for the entire program is defined as in the following code snippet.
\begin{lstlisting}[language=Haskell, style=custom-style]
program :: Parser Block
program = do keyword "shrimp"; block

parse :: String -> Result (Block, String)
parse cs = case unwrap program cs of
  [] -> Error EmptyProgram
  [(b, cs)] -> Ok (b, cs)
\end{lstlisting}

\section*{The Optimizer}
The \textit{optimization} process is an intermediate step between the parsing and the interpretation of the program itself.
Currently, the main optimization step is related to the execution of constant values.
That is, if an expression in a loop is defined only on constant values, it's better to optimize the computation of that expression by replacing it with the result.
This procedure is done before the interpretation of the program.
For example, consider the following arithmetic expression, expressed in intermediate representation, that we wish to optimize.
\begin{lstlisting}[language=Haskell, style=custom-style]
let expr = Div (
    (Mul (Identifier "x") (Sub (Constant 5) (Constant 3)))
    (Add (Constant 9) (Constant 1)))
\end{lstlisting}
If we apply the optimization step to this arithmetic expression, we obtain the equivalent but more efficient arithmetic expression.
\begin{lstlisting}[language=Haskell, style=custom-style]
let expr' = Div (Mul (Identifier "x") (Constant 2)) (Constant 10)
\end{lstlisting}
The implementation of the \textit{optimization} process in Haskell is straightforward, due to simple recursion functions.
A very similar optimization process is also implemented on boolean expressions.
The \textit{optimization} process also includes a basic optimization on commands such as \texttt{skip}, \texttt{if-then-else} and \texttt{while-do}.
First of all, all the \texttt{skip} commands are removed from the intermediate representation.
Moreover, if the condition of a \texttt{if-then-else} command is always \textit{true} then the entire statement is replaced with the first block of commands.
In a similar way, if the condition is always \textit{false} then the entire statement is replaced with the second block of commands.
Furthermore, this approach is also used for \texttt{while-do} commands.
That is, if the condition of a \texttt{while-do} command is always \textit{false} then the entire statement is completely removed.
However, if the condition is always \textit{true} then an exception named \textit{Infinite Loop} is raised.
In other words, the optimizer is capable of detecting trivial infinite loops and prevents the interpretation of such programs.

\end{document}